{"ast":null,"code":"import _isFunction from \"lodash/isFunction\";\n\nvar _class, _class2, _temp;\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n/**\n * @fileOverview Axis of radial direction\n */\n\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport pureRender from '../util/PureRender';\nimport Layer from '../container/Layer';\nimport { PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, SCALE_TYPES, getPresentationAttributes, filterEventsOfChild } from '../util/ReactUtils';\nimport Dot from '../shape/Dot';\nimport Polygon from '../shape/Polygon';\nimport Text from '../component/Text';\nimport { polarToCartesian } from '../util/PolarUtils';\nvar RADIAN = Math.PI / 180;\nvar eps = 1e-5;\n\nvar PolarAngleAxis = pureRender(_class = (_temp = _class2 =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(PolarAngleAxis, _Component);\n\n  function PolarAngleAxis() {\n    _classCallCheck(this, PolarAngleAxis);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolarAngleAxis).apply(this, arguments));\n  }\n\n  _createClass(PolarAngleAxis, [{\n    key: \"getTickLineCoord\",\n\n    /**\n     * Calculate the coordinate of line endpoint\n     * @param  {Object} data The Data if ticks\n     * @return {Object} (x0, y0): The start point of text,\n     *                  (x1, y1): The end point close to text,\n     *                  (x2, y2): The end point close to axis\n     */\n    value: function getTickLineCoord(data) {\n      var _this$props = this.props,\n          cx = _this$props.cx,\n          cy = _this$props.cy,\n          radius = _this$props.radius,\n          orientation = _this$props.orientation,\n          tickLine = _this$props.tickLine;\n      var tickLineSize = tickLine && tickLine.size || 8;\n      var p1 = polarToCartesian(cx, cy, radius, data.coordinate);\n      var p2 = polarToCartesian(cx, cy, radius + (orientation === 'inner' ? -1 : 1) * tickLineSize, data.coordinate);\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y\n      };\n    }\n    /**\n     * Get the text-anchor of each tick\n     * @param  {Object} data Data of ticks\n     * @return {String} text-anchor\n     */\n\n  }, {\n    key: \"getTickTextAnchor\",\n    value: function getTickTextAnchor(data) {\n      var orientation = this.props.orientation;\n      var cos = Math.cos(-data.coordinate * RADIAN);\n      var textAnchor;\n\n      if (cos > eps) {\n        textAnchor = orientation === 'outer' ? 'start' : 'end';\n      } else if (cos < -eps) {\n        textAnchor = orientation === 'outer' ? 'end' : 'start';\n      } else {\n        textAnchor = 'middle';\n      }\n\n      return textAnchor;\n    }\n  }, {\n    key: \"renderAxisLine\",\n    value: function renderAxisLine() {\n      var _this$props2 = this.props,\n          cx = _this$props2.cx,\n          cy = _this$props2.cy,\n          radius = _this$props2.radius,\n          axisLine = _this$props2.axisLine,\n          axisLineType = _this$props2.axisLineType;\n\n      var props = _objectSpread({}, getPresentationAttributes(this.props), {\n        fill: 'none'\n      }, getPresentationAttributes(axisLine));\n\n      if (axisLineType === 'circle') {\n        return React.createElement(Dot, _extends({\n          className: \"recharts-polar-angle-axis-line\"\n        }, props, {\n          cx: cx,\n          cy: cy,\n          r: radius\n        }));\n      }\n\n      var ticks = this.props.ticks;\n      var points = ticks.map(function (entry) {\n        return polarToCartesian(cx, cy, radius, entry.coordinate);\n      });\n      return React.createElement(Polygon, _extends({\n        className: \"recharts-polar-angle-axis-line\"\n      }, props, {\n        points: points\n      }));\n    }\n  }, {\n    key: \"renderTicks\",\n    value: function renderTicks() {\n      var _this = this;\n\n      var _this$props3 = this.props,\n          ticks = _this$props3.ticks,\n          tick = _this$props3.tick,\n          tickLine = _this$props3.tickLine,\n          tickFormatter = _this$props3.tickFormatter,\n          stroke = _this$props3.stroke;\n      var axisProps = getPresentationAttributes(this.props);\n      var customTickProps = getPresentationAttributes(tick);\n\n      var tickLineProps = _objectSpread({}, axisProps, {\n        fill: 'none'\n      }, getPresentationAttributes(tickLine));\n\n      var items = ticks.map(function (entry, i) {\n        var lineCoord = _this.getTickLineCoord(entry);\n\n        var textAnchor = _this.getTickTextAnchor(entry);\n\n        var tickProps = _objectSpread({\n          textAnchor: textAnchor\n        }, axisProps, {\n          stroke: 'none',\n          fill: stroke\n        }, customTickProps, {\n          index: i,\n          payload: entry,\n          x: lineCoord.x2,\n          y: lineCoord.y2\n        });\n\n        return React.createElement(Layer, _extends({\n          className: \"recharts-polar-angle-axis-tick\",\n          key: \"tick-\".concat(i)\n        }, filterEventsOfChild(_this.props, entry, i)), tickLine && React.createElement(\"line\", _extends({\n          className: \"recharts-polar-angle-axis-tick-line\"\n        }, tickLineProps, lineCoord)), tick && _this.constructor.renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value) : entry.value));\n      });\n      return React.createElement(Layer, {\n        className: \"recharts-polar-angle-axis-ticks\"\n      }, items);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props4 = this.props,\n          ticks = _this$props4.ticks,\n          radius = _this$props4.radius,\n          axisLine = _this$props4.axisLine;\n\n      if (radius <= 0 || !ticks || !ticks.length) {\n        return null;\n      }\n\n      return React.createElement(Layer, {\n        className: \"recharts-polar-angle-axis\"\n      }, axisLine && this.renderAxisLine(), this.renderTicks());\n    }\n  }], [{\n    key: \"renderTickItem\",\n    value: function renderTickItem(option, props, value) {\n      var tickItem;\n\n      if (React.isValidElement(option)) {\n        tickItem = React.cloneElement(option, props);\n      } else if (_isFunction(option)) {\n        tickItem = option(props);\n      } else {\n        tickItem = React.createElement(Text, _extends({}, props, {\n          className: \"recharts-polar-angle-axis-tick-value\"\n        }), value);\n      }\n\n      return tickItem;\n    }\n  }]);\n\n  return PolarAngleAxis;\n}(Component), _class2.displayName = 'PolarAngleAxis', _class2.axisType = 'angleAxis', _class2.propTypes = _objectSpread({}, PRESENTATION_ATTRIBUTES, EVENT_ATTRIBUTES, {\n  type: PropTypes.oneOf(['number', 'category']),\n  angleAxisId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  dataKey: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.func]),\n  cx: PropTypes.number,\n  cy: PropTypes.number,\n  radius: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  hide: PropTypes.bool,\n  scale: PropTypes.oneOfType([PropTypes.oneOf(SCALE_TYPES), PropTypes.func]),\n  axisLine: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  axisLineType: PropTypes.oneOf(['polygon', 'circle']),\n  tickLine: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n  tick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func, PropTypes.object, PropTypes.element]),\n  ticks: PropTypes.arrayOf(PropTypes.shape({\n    value: PropTypes.any,\n    coordinate: PropTypes.number\n  })),\n  stroke: PropTypes.string,\n  orientation: PropTypes.oneOf(['inner', 'outer']),\n  tickFormatter: PropTypes.func,\n  allowDuplicatedCategory: PropTypes.bool\n}), _class2.defaultProps = {\n  type: 'category',\n  angleAxisId: 0,\n  scale: 'auto',\n  cx: 0,\n  cy: 0,\n  domain: [0, 'auto'],\n  orientation: 'outer',\n  axisLine: true,\n  tickLine: true,\n  tick: true,\n  hide: false,\n  allowDuplicatedCategory: true\n}, _temp)) || _class;\n\nexport default PolarAngleAxis;","map":null,"metadata":{},"sourceType":"module"}